# Welcome to the Atlas Engine source code!

This is the source code for Atlas Eninge, a C++ written
game engine based on Lua game development!.

## What is Atlas Engine?

Atlas Engine is a low-level game engine coded in C++,
it offers language suppourt for Lua programming allowing
games to be made in a very low-level game engine.

The engine has no UI and relies entirely on the user writing
Lua code to handle the generation of their sprites, though
the majority of the rendering is handled behind the scenes
by the C++ core of the engine.

## How is Atlas Engine built?

Atlas Engine is made up of two parts, and is more of a Lua
library than it is a game enigne. There is the core library,
which contains all of the C++ code for handing the internal
engine, and there is the extended logic, written by the user
through both Lua functions that send signals to the Core, and
Lua game logic for the actual game.

## Compatibility

Atlas Engine will likely first only be compatible with Windows
10/11 initially, but I do intend to build it with compatibility
in mind, mainly with Linux. It is very unlikely I will create
a version to integrate with MacOS or Apple at all. This is
because Apple is super stingy with their ecosystem.

## Flow of creating a project

The flow of creating a project is likely going to be a little
strange mainly because of the lack of abstraction between the
core and extended logic written by the user. Despite that there
are a couple solutions to handling a build run style game eninge.

### Why use a build run arcitecture?

A build run arcitecture is very important to any good game engine,
essentially it separates the initial creation of meshes, textures,
shaders, ect, with the actual gameplay logic. The idea of building
a game is that it will generate a distributable game file for the
user so that they don't need to set it up themselves. So the flow
of this would go something like this.

> Import Core libs -> Add sprites and textures -> write extended logic (game logic) -> polish -> build and export game -> distribute .exe file with its dependencies

Its important to note that we need to ensure no more than 1 .hpp/.h file is
distributed with any particular game.

The fix to the build run issue would be to create a 1 off Lua script
generated by the game engine, this script when run will build the
entire game for the user abstracting away any complex setup. This
one off script could also act as an entry point for the actual project
though I haven't even started to consider Lua integration to the game
engine yet.

## OpenGL and other reqirements

We will be using OpenGL for the majority of the rendering paired with the common Open source library for renderering,
SDL. On top of that, to make loading the OpenGL calls much easier, since it includes less boiler plate, we will also
be using GLAD along with everything. The majority of the project is compiled using CMake with a sub-directory system.
This will provide structure to the project and make CMake files much easier to debug. The CMake files are not auto
generated and are written entirely by me.

> Permalink to GLAD download: https://glad.dav1d.de/#language=c&specification=gl&api=gl%3D4.6&api=gles1%3Dnone&api=gles2%3Dnone&api=glsc2%3Dnone&profile=core&loader=on

The above permalink describes what version and features of OpenGL I am taking advantage of.

## Project Overview

### Creating the neccessary subsystems:

There are two subsystems needed for the engine to work, the window class,
and the renderer subsystems. The window class is a static class designated
to creating the main game window, this mean the engine only suppourts one
window.

### Entity Component System!!!

This is the most important part of the engine, as it makes the creation of complex and dynamic
game objects actually possible while keeping my sanity and keeping the repo maintainible.
The concept is simple in concept, every entity has a unique ID, entitys also have components
attached to them. An entity is the same idea as a gameobject like in Unity. An entity for
example "Player", might have a renderer component, a transform component, a texture component,
ect. This system adds a lot of dynamic aspects to the engine, but is also wildly more complex
because of a certain C++ concept known as **circular dependencies**.

### Adding major rendering features:

Add texture processing, and separate dynamic and static sprites into their
own groups.

#### Dynamic Sprites

Dynamic sprites are sprites that are free to move around on the screen freely,
this inclues rescaling, translating, and rotating itself. Dynamic sprites are
significantly slower in comparison to **static sprite** mainly because they
cannot be batched by OpenGL. Each dynamic object has its own VAO, VBO, and EBO.
As well as its own texture buffer and optionally its own shader. These features
do give the user more control over the object, but its at the cost of performance,
as any time OpenGL wants to render the sprite it must swap the buffer which adds
many extra steps under the hood.

#### Static Sprites

Static sprites, while more difficult to code into the game engine because of the
need to code a texture atlas algorithm and handle batching, is significantly simpler
and more efficient for the OpenGL renderer to handle. There are however some drawbacks
to using a static sprite that being you cannot modify its position, size, or rotation
without modifying every other static sprite on the screen. This means that while you can
move static sprites freely around, they must all move at the same time. The current goal
is to have it so that you can still animate static sprites, but that will likely prove
difficult do to the use of a texture atlas to handle the rendering of sprites.

#### Texture atlasing

A texture atlas is essentially a group of textures all on one giant image. The biggest
struggle with texture atlasses is the reqirement of the use of a **packing algorithm**.
The easiest and quickest (while not most optimal way) to handle atlas creation would be
the use of a packing algorithm known as the **Skyline Packing Algorithm**. This algorithm
is well known for its speed, and simplicity making it easy to use. The biggest issue
however would be figuring out how to decode PNGs and JPEGs as well as any other image
file types we would also like to include, this issue is solved with the use of an important
open source C++ library known as **stb_image_write** and **stb_image**. Both of these libs
are header only files meant to abstract away the decoding of PNGs and JPEGs, while it might
be fun to write these myself, I am already avoiding the use of the **stb_rect_pack** lib
mainly so I can maintain as much control as possible in the functionality of the code.

#### Sprite animations

Sprites are commonly animated through the use of sprite sheets, sprite sheets are in essence
very simmilar to texture atlases, there is one major difference between them however. You
can you of a texture atlas as almost a grouping of different sized textures into one image
file, this is why you need a packing algorithm to handle the creation of them, however, with
a sprite sheet, all images are the same size, so all we really need to do is just create a long
line of the images with a quick and simple image manipulation algorithm. We will still likely
use some libs like stb_image and stb_image_write, but the implementations will not require any
fany packing algorithm.

Sprite animations are a high level class that will allow the programmer to:

- Generate a sprite sprite sheet with a certain name.
- Set the animations position using an indexing/frameID system.
- Play the animation at a certain speed by adding it to an animation stream or an async function (If C++ suppourts those).

[Under Construction]
